# 基础概念

### 1. 尾递归(尾调用)  

尾递归的基本概念解释如下：  

> 在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。  
尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：
> - 调用自身函数 (Self-called)；
> - 计算仅占用常量栈空间 (Stack Space)。  

> 而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。

它是一种特殊的递归，意在优化普通的递归模式。尾递归使用从前往后的迭代模式，占用O(1)栈控件，不会像递归一样存在调用栈溢出的情况。对栈控件的使用也是普通递归和尾递归的主要区别。以C语言计算N以内的数叠加和为例，普通的递归如下：  

```C
int recursionSum(int num) {
    if(num == 1) {
        return 1;
    }
    
    return num + recursionSum(num - 1);
}
```  

当传入参数5，recursionSum(5)的计算过程如下：  

```C
recursionSum(5)
5 + recursionSum(4)
5 + (4 + recursionSum(3))
5 + (4 + (3 + recursionSum(2)))
5 + (4 + (3 + (2 + recursionSum(1))))
5 + (4 + (3 + (2 + 1)))
5 + (4 + (3 + 3))
5 + (4 + 6)
5 + 10
15
```  

普通递归看似在函数执行时是从前往后计算的，但实际运行却需要运行到递归终点后才可以从后往前计算，而运行到这个终点时，整个程序便占用了递归层次的栈空间。在递归层次很深时，就可能存在栈溢出的情况。  

之后，修改代码使用尾递归的形式实现：  

```C
int tailRecursion(int num, int sum = 0) {
    if(num == 1) {
        return sum;
    }

    return tailRecursion(num - 1, sum + num);
}
```  

从另一种角度看，尾递归很像是循环的一种特殊实现方式，以上代码的实现和循环相当相似：  

```C
sum = 0,index = 1;
while(index <= num) {
    sum += index;
    ++index;
}
```  

同样是计算5以内数的综合，使用尾递归的调用堆栈如下：  

```C
tailRecursion(5，0)
tailRecursion(4，5)
tailRecursion(3，9)
tailRecursion(2，12)
tailRecursion(1，14)
15
```  

实现难度跟普通递归类似，但是运行时占用的栈空间却被大幅优化。
