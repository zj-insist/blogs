# 《Effective Objective-C 2.0》读书笔记  

1. 尽可能不在头文件中引入其他头文件  

- 编译其间，头文件并不关心引入文件的内部实现，此时可以使用 `@class someClass` 的`向前声明`的方式通过编译。因为引入头文件后编译器就会把相应的头文件复制到引用的文件内，而向前声明的方式省略了这一步，可以减少部分编译时间；此外，这种方式也可以有效避免两个文件的循环引用导致编译不通过，以及文件间的耦合。  

- 在引入的头文件中包含协议等内容必须要引入时，最好的做法是声明一个引入协议这个类的category，然后再在这个category引入头文件，这么做的意义是为了降低彼此的依赖关系（书中表示还可以缩短编译时间，暂时没有理解）。个人理解是，这种方案遵循`只在使用时引用的原则`，因为协议肯定要搭配实现的代理方法使用，声明category用于统一管理代理方法，只有这个代理需要这个协议的声明，这样就降低了category原有类和协议之间的依赖。如果不偏向这种设计，还可以将协议单独放到一个头文件，要引用的时候导入。

---   

2. 尽可能多的使用字面量语法创建OC对象  

- 多使用如下中字面量的方式代替方法的方式创建OC对象，这样做的目的是可以让代码简洁，字面量的方式也不过是OC的语法糖，方便创建对象的一种写法，实际还是需要调用方法，用这种方式创建时，如果对象中包含nil会直接报错，方便定位，当然，不便之处在于不可变类型的对象不能用这种方式创建，解决方式也很简单，拷贝一份此类对象的可变副本即可

```objc
    //字面量
    NSString *strValue = @"我是一个字符串";
    //方法创建
    NSString *strMethod = [NSString stringWithFormat:@"我也是一个字符串"];
    //字面量
    NSNumber *numValue = @1;
    //方法创建
    NSNumber *numMethod = [NSNumber numberWithInteger:1];
    //字面量
    NSArray *arrValue = @[@"1",@"2"];
    //方法创建
    NSArray *arrMethod = [NSArray arrayWithObjects:@"1", @"2", nil];
    //字面量
    
    NSDictionary *dicValue = @{@"key1":@"value1",
                               @"key2":@"value2"};  
    //方法创建
    NSDictionary *dicMethod = [NSDictionary dictionaryWithObjectsAndKeys:@"value1", @"key1", @"value2", @"key2", nil];
```
- 多使用下标的方式访问数组或者字典，原理和对象的创建一样，可以让代码看起来更简单易懂，而不是包含大量方法名   

---

3. 多用常量代替预处理指令#define  

- #define只是一个简单的替换处理，而常量可以显示比如类型等更多的信息，而且使用const关键字可以防止使用过程中被修改  

- 使用`static type const`修饰编译单元内的常量，定义在编译单元的实现文件中，常量命名使用k作为前缀，使用这种方式定义的常量和#define定义的常量类似，但是只在编译单元内做替换工作，优势是包含类型信息  

- 使用`extern type const`修饰全局常量，命名使用类前缀作为修饰避免命名冲突，在头文件中声明常量，并在实现文件中给出常量的值  

---  

4. 使用枚举表示状态相关内容  

- 使用枚举代替int、string等值代表的状态码，可以让程序更加通俗易懂，此外应该尽量使用系统定义的NS_ENUM类型或者NS_OPTION宏定义来定义枚举，这样可以自己定义枚举的类型  

- 在使用switch处理枚举时，不实现default分支。这样在我们新加入状态后，编译器会有警告信息，以便定位以及调整switch  

---  

5. 在对象内部尽量直接访问实例变量  

- 通过实例变量访问不会调用setter和getter方法，不经过消息转发，拥有更高的效率  

- 设置值时，使用属性会调用setter方法，这样可以跟踪属性设置的流向和进行断点调试  

- 实例变量的访问方式不调用KVO  

- 使用属性设置值时需要注意，如果在子类中重写了setter方法，子类的初始化其实会调用重写的setter方法  

- 使用属性的访问方式更便于懒加载的实现  

- 属性和实例变量的方式选择要根据实际情况确定，主要的考虑因素是对象的访问需不需要经过setter或者geter方法，需要则使用属性，不需要则使用实例变量，一般在对象的初始化和dealloc方法中，总是应该使用实例变量读写数据  

---  

6. “对象等同性”概念  

- 