# 学习笔记  

## 语法基础

- 多行注释可以用多个 # 号，还有 ''' 和 """    

- python使用规范的缩进代替大括号，当缩进不一样时代码表达的意思便不一样，不规范的缩进会导致编译失败  

- 字符串相关  

    1. 使用三引号 ('''或""") 可以指定一个多行字符串  

    2. 自然字符串， 通过在字符串前加 r 或 R。 如 r"this is a line with \n" 则 \ n 会显示，并不是换行  

    3. 按字面意义级联字符串，如 "this" "is" "string" 会被自动转换为 this is string  

- print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=""

- **import 与 from...import**  

    1. 将整个模块 (somemodule) 导入，格式为： import `somemodule`  

    2. 从某个模块中导入某个函数, 格式为： from `somemodule` import `somefunction`  

    3. 从某个模块中导入多个函数, 格式为： from `somemodule` import `firstfunc`, `secondfunc`, `thirdfunc`  

    4. 将某个模块中的全部函数导入，格式为： from `somemodule` import `*`  

- Python3使用 `and`、`or` 和 `not` 代替 `&&` 、 `||` 和 `!` 进行逻辑运算

- 可以使用 `in` 和 `not in` 判断一个元素是否存在在某个序列  

- Python3中判断相等和不等还有 `is` 和 `not is` 关键字，其与 `==` 和 `！=` 主要区别是 `is` 等主要用来判断引用是否相等，而 `==` 只判断值相等   

- python使用如下方式进行一个序列的遍历：  

    ```python
    #python
    for i in range(len(a)):
        print(i, a[i])

    #other
    for(int index = 0; index < len(a); index++)
        print(index,a[index])
    ```
  
- `pass` 关键字不做任何操作，仅用来保证程序结构完整性，作为占位语句

## 基本数据类型  

- python3允许如下赋值方式，按照顺序给变量赋值：  

```python
a = b = c = 1  

a, b, c = 1, 2, "runoob"  
```  

- python3支持以下6种数据类型：  

    - Number（数字）  
    - String（字符串）  
    - List（列表）  
    - Tuple（元组）  
    - Sets（集合）  
    - Dictionary（字典）  

- 以上6中类型中，除了 `Number` 、 `Sets` 以及 `Dictionary`类型外 ， `*` 可以用来做复制操作，在 `*` 后跟数字代表复制当前对象几次，以字符串为例，可以用以下方式打印2次 `Str` ：  

    ```python
    Str = 'Jie'
    print (Str * 2)
    # JieJie
    ```  

### Number  

- Python3 支持 int、float、bool、complex（复数），可使用内置的 `type()` 函数查询变量所指的对象类型    

    `isinstance` 也可以用来判断类型，使用方式如下：  

    ```python
    isinstance(11, int) 
    # True
    ```     

    两者的区别:  
    `isinstance()` 会认为子类是父类的类型  
    `type()` 不会认为子类和父类是一样的类型  
    
- 数值除法将默认会返回浮点数，使用 `//` 代替 `/` 做整数除法， `//` 使用去尾法得到运算后的数字  

- python3 使用 `A ** B` 方式做幂运算

- 在运算过程中 `int` 类型数据的计算常常会被转换成 `float` 类型  

- `round(x [,n])`	返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数

### String  

- python3 中的字符串是不能被修改的  

- Python3 使用如下方式进行解包：  

    ```python
    print (" 我叫 %s 今年 %d 岁!" % ('小明', 10))
    # 我叫 小明 今年 10 岁!
    ```

### List  

- 列表可以存储不同类型的数据

### Tuple  

- 元组与数组的唯一区别是元组是不可变的，而数组时可变的，元组使用 `()` 表示  

### Set  

- 创建 `Set` 可以使用 `{ }` 或者 `set()` ，但是创建空集合必须用 `set()` 而不是 `{ }`，因为 `{ }` 是用来创建一个空字典。

## 函数  

- python中的值传递和引用传递同C  

- python中函数可以指定关键字参数，使用关键字参数可以忽视参数传入的顺序  

    ```python
    def printinfo( name, age ):
        "打印任何传入的字符串"
        print ("名字: ", name);
        print ("年龄: ", age);
        return;
 
    #调用printinfo函数
    printinfo( age=50, name="runoob" );
    ```   


- 使用 `def printinfo( arg1, *vartuple )` 的方式声明一个不固定参数个数的函数，获取参数时使用 `for` 语句即可

- 匿名函数  
    `python` 使用 `lambda` 创建匿名函数。匿名函数式不适用 `def` 来定义的函数，实质上匿名函数拥有如下特点：  

    - `lambda` 只是一个表达式，函数体比 `def` 简单很多。  
    - `lambda` 的主体是一个表达式，而不是一个代码块。仅仅能在 `lambda` 表达式中封装有限的逻辑进去。
    - `lambda` 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
    - 虽然 `lambda` 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。  

    **（从以上与 C 中的内联函数对比， `lambda` 函数的主要作用仅仅是为了做一个临时的简洁的表达方式，不需要多创建一个污染整个代码阅读环境的函数）**  


- `global` 和 `nonlocal` 关键字  

    当内部作用域想修改外部作用域的变量，需要使用 `global` 和 `nonlocal` 关键字。不使用这两个关键字去引用作用于外的变量会出现变量未定义的错误：  
    
    ```python
    a = 10
    def test():
        a = a + 1
        print(a)
    test()
    #报错 UnboundLocalError: local variable 'a' referenced before assignment
    ```  

    引用全局作用于变量：  
    ```python
    num = 1
    def fun1():
        global num  # 需要使用 global 关键字声明
        print(num) 
        num = 123
        print(num)
    fun1()
    ```  

    引用局部作用于变量：  
    ```python
    def outer():
        num = 10
        def inner():
            nonlocal num   # nonlocal关键字声明
            num = 100
            print(num)
            inner()
            print(num)
    outer()
    ```  
    
## 模块  

- 使用 `from XXX import *` 将把模块内的除了由单 `_` 开头的内容导入。一般不建议使用此方式，会出现命名重复的情况  

- 模块在被导入时，其主程序将执行初始化操作，如果希望在导入时不执行主程序，可以使用 `__name__` 关键字，具体操作如下：  

    ```python
    if __name__ == '__main__':
        print('程序自身在运行')
    else:
        print('我来自另一模块')

    $ python using_name.py
    程序自身在运行

    $ python
    >>> import using_name
    我来自另一模块
    >>> 
    ```   

- `dir()` 可以用于列出一个模块中所有已定义的名称，没有参数时，列出当前模块中的所有名称  

- python 中使用包的概念统一管理不同的模块，目录只有包含一个叫做 `__init__.py` 的文件才会被认作是一个包

- 使用点语法对包的层级进行访问，使用不同的导入方式，引用方式也有区别：  

    ```python
    #使用 import 导入的包的引用需要使用完整路径
    import sound.effects.echo

    sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)  

    #使用 from 方式导入则可以直接使用  
    from sound.effects import echo  

    echo.echofilter(input, output, delay=0.7, atten=4)

    ```

- 在包的 `__init__.py` 文件中键入如下内容：  

    > \_\_all__ = ["a", "b", "c"]  

    表示在使用 `from A import *` 这种操作时，只能引入包里的 a,b,c 三个模块，当没有 `__all__` 定义时，`improt *` 将不会引入包内的任意一个模块  


## 错误和异常

- try except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。这个子句将在 try 子句没有发生任何异常的时候执行。使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而 except 又没有捕获的异常。  

- 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。  

- 可以使用 `raise` 抛出一个异常  

- try 语句还有另外一个可选的子句 finally ，它定义了无论在任何情况下都会执行的清理行为  

- 预定义清理行为，关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:  

    ```python
    with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
    ```  

## 面向对象  

- python中类的私有对象和方法在命名时前添加 `__`   

- 类方法必须包含 `self` 关键字，且为第一个参数